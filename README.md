# Frontend Interview - Website

Hi ðŸ‘‹,

I thought Iâ€™d spend a few words explaining what I did and why, and to briefly describe my overall approach.

The first thing I did was introduce routing with `react-router-dom`. Itâ€™s a simple app, so there are basically two routes: the home route `/` and a `NotFound` route for any URL the app does not support. I always try to keep things tidy, so I keep all routes in a `routes.ts` file and then lazy-load and map them inside `App.tsx`. In a small app with only a few routes, lazy loading does not really make a big difference performance-wise, but it reflects the way I usually structure projects, loading code only when the user actually needs it.

I also added an `ErrorBoundary` component to make sure that if a route or component crashes, the user is presented with a friendly error screen instead of a broken app.

Then I worked on the UI and styles. I created a few CSS files inside the `styles` directory. There is a `tokens.css` file which contains all CSS variables and shared values used across the app, to keep things consistent and organised. There is also a `components.css` file which defines reusable classes such as `.card`, `.badge`, and similar utility styles. This helps keep styling structured and easier to maintain.

After that, I moved on to creating the React components, using mock data when needed. Components such as `Card`, `Badge`, `LoadingSpinner`, `SearchBar`, and others were implemented, as well as the `Modal`, which uses the `createPortal` API to display user details when opened.

Once all CSS files and static components were in place, I moved on to the business logic.

For fetching data, I used the free DummyJSON API, specifically the users endpoint:

https://dummyjson.com/docs/users

The main source of truth is the `useUsers` hook, which is responsible for fetching and storing data. It exposes loading and error states and also handles pagination, state resets when needed, and related logic, and also includes caching logic to make the UI feel more responsive when the user happens to trigger the same search again.

Data is fetched using the fetch API and I also added an AbortController, which might not be that useful in this specific scenario, as I donâ€™t really see the user being able to make many requests very fast, since the request is handled only after the search button is clicked. If fetch was happening on every keystroke while typing, then it would have been 100% needed to avoid stale fetches and prevent race conditions. Nonetheless, I added it anyway.

While working on this, I realised that the DummyJSON API does not allow combining search and filter at the same time. Because of that, there are two different API URLs depending on whether the user is searching or filtering by role. This is why there is conditional logic inside the hook to decide which endpoint to call.

Another limitation I found is that searching by full name (for example, first name and last name together) does not work as expected. Searching by only first name or only last name works correctly, but when both are combined in a single query, the API treats it as one string instead of two separate values, so no results are returned.

Because of these API limitations, some parts of the implementation are a bit more constrained than I would normally like. I apologise if this makes a few areas feel less flexible or less elegant than they could be, but I felt it was better to stay honest to the API behaviour rather than add workarounds just to make things look cleaner. In a real-world scenario, I would expect the backend to support combined search and filtering, as well as proper full-name search, which would make the client-side implementation much simpler and more intuitive.

So that point I was already quite deep into the implementation, so I decided to continue with this API and handle these limitations rather than switching to a different data source.

I also added pagination, since it is always better than showing a very long list of results at once, both from a UI and a backend perspective.

The `useUsers` hook is then used inside `Home.tsx`, where its returned values and methods are passed down to child components.

Another hook is `useUserModal`, which centralises the logic for selecting the user that will be displayed inside the modal popup.

I always try to think about user experience, so I added different UI states depending on whether the search returned results or not, whether it was a search or a filter, and whether an error occurred.

I also added testing using Vitest. The coverage percentage is 100%, with each component and helper utility function being tested. I added the `@vitest/coverage-v8` package to generate coverage results.

Coverage can be generated by running:

`npm run test:coverage`

All tests can also be run using:

`npm run test`

This command creates a `/coverage` directory at the root of the project containing an HTML report that can be opened in the browser, showing the coverage percentage for each component, file, and function.

### Last thoughts

If I didn't have the constraint of not using third-party libraries, I would have used `Axios` instead of the native `Fetch` API, mainly because Iâ€™m more comfortable with its API and I find the error handling a bit clearer.

For caching and request state, I would have used `TanStack Query`. It would take care of most of the things Iâ€™m currently handling manually, like caching, setting up loading and error states etc, it would make this part of the code much simpler.

And for state management, I would likely go with `Zustand`. I like how lightweight it is and how easy it is to reason about, especially compared to more complex state management solutions.

That's all

Thanks :)

## Install and run

```bash
# Install dependencies
# This project use `pnpm` as package manager, but you can use also `npm` or `yarn`.
pnpm install

# And run the project
pnpm dev

# Run all tests
pnpm run test

# Run tests with coverage
pnpm run test:coverage
```

## Figma file

The figma file of the home test is available [here](https://www.figma.com/design/ESP3mNtKRj1aI458c08QBb/%F0%9F%92%BB-Website-Home-Test?node-id=0-1&t=tmrCaYq4wADJCHvD-1).
